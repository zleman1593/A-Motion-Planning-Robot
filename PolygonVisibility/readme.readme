Zackery Leman & Ivy Xing
Computational Geometry
A C++ implementation to compute the shortest path of a simple polygon robot around polygon obstacles from a start to end point.

****** General Information ******


- Key press:
'e': Exists polygon obstacle drawing mode.
'm': Calculates and draws the shortest path. Makes the robot move automatically from start to finish.
'q': Quits the program.

- Color and shapes:
The polygon obstacles are drawn with RED LINES.
The vertices have HOLLOW RED CIRCLES drawn around them until the polygons are complete.
The start point is a FILLED GREEN CIRCLE.
The end point is a FILLED RED CIRCLE.
The robot is a BLUE SQUARE.
The shortest path is a BLUE PATH.



********** Instructions **********

(1) Drawing the polygon obstacles and the start & end points:
- Click anywhere to draw a polygon vertex.
- When you draw the next vertex, an edge will be drawn to connect them (see a in Notes).
- To finish drawing the polygon, click back on the first vertex.
- After you finish the polygon, the next mouse click starts drawing another polygon in a similar fasion.
- Press 'e' to stop obstacle drawing mode once you have drawn the last polygon obstacle.
- Click once for start.
- Click  again for end point.
- Notes:
    a. If the mouse click leads to polygon self-intersection, no vertex/edge will be drawn.
    b. If the start or end point is outside the polygon, it won't be drawn.

(2) Click 'm' to draw path.

(3) Click 'm' to move the robot along the path again in alternating directions.


Note: Because we only allow vertical and horizontal movement, even though the algorithm will find the shortest path using only these movements, it may not look like it found the shortest path. This is because instead of looking like it moves diagonally from start to end,  it may go straight down and then across at a right angle because this is technically equivalent to taking alternating vertical and horizontal steps, which would look more like a diagonal movement.
 We have use a heuristic modified BFS (like A*) to find shortest path because edge weights are all 1 since we don't allow diaginal movement. (i.e we didnt implement the Relaxing part of Dijkstra)



